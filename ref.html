<!DOCTYPE html>
<html>
<head>
    <title>Titan's Circuit</title>
    <style>
        .game-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }
        #game-board {
            width: 100%;
            height: 600px;
        }
        .scoreboard {
            display: flex;
            justify-content: space-between;
            padding: 10px;
        }
        .controls {
            text-align: center;
            padding: 10px;
        }
        .turn-info {
            text-align: center;
            padding: 10px;
        }
        @media (max-width: 600px) {
            #game-board {
                height: 400px;
            }
        }
        .selected {
            stroke: yellow;
            stroke-width: 4;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="scoreboard">
            <div class="player-score red">Red: 0</div>
            <div class="timer">Overall Time: <span id="overall-timer">10:00</span></div>
            <div class="player-score blue">Blue: 0</div>
        </div>
        <svg id="game-board" xmlns="http://www.w3.org/2000/svg"></svg>
        <div class="controls">
            <button id="pause-btn">Pause</button>
            <button id="reset-btn">Reset</button>
        </div>
        <div class="turn-info">
            Current Player: <span id="current-player">Red</span>
            <br>
            Turn Time: <span id="turn-timer">30</span>
        </div>
    </div>
    <script>
        class Game {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.players = {
                    red: { titansPlaced: 0, score: 0 },
                    blue: { titansPlaced: 0, score: 0 }
                };
                this.currentPlayer = 'red';
                this.phase = 'placement';
                this.unlockedCircuits = ['outer'];
                this.overallTimer = 600;
                this.turnTimer = 30;
                this.isPaused = false;
                this.intervalId = null;
                this.selectedTitan = null;
                this.initGame();
            }

            initGame() {
                this.createNodes();
                this.createEdges();
                this.startTimers();
                this.render();
            }

            createNodes() {
                const circuits = [
                    { name: 'outer', radius: 200 },
                    { name: 'middle', radius: 120 },
                    { name: 'inner', radius: 40 }
                ];
                const centerX = 400;
                const centerY = 300;

                circuits.forEach(circuit => {
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60 - 30) * (Math.PI / 180);
                        const x = centerX + circuit.radius * Math.cos(angle);
                        const y = centerY + circuit.radius * Math.sin(angle);
                        this.nodes.push({
                            id: `${circuit.name}-${i}`,
                            circuit: circuit.name,
                            x: x,
                            y: y,
                            occupant: null
                        });
                    }
                });
            }

            createEdges() {
                ['outer', 'middle', 'inner'].forEach(circuit => {
                    for (let i = 0; i < 6; i++) {
                        const next = (i + 1) % 6;
                        const node1 = this.nodes.find(n => n.id === `${circuit}-${i}`);
                        const node2 = this.nodes.find(n => n.id === `${circuit}-${next}`);
                        const weight = circuit === 'outer' ? 1 : circuit === 'middle' ? 5 : 15;
                        this.edges.push({
                            id: `${circuit}-${i}-${circuit}-${next}`,
                            nodes: [node1.id, node2.id],
                            weight: weight,
                            controlledBy: null
                        });
                    }
                });

                for (let i = 0; i < 6; i++) {
                    const outerNode = this.nodes.find(n => n.id === `outer-${i}`);
                    const middleNode = this.nodes.find(n => n.id === `middle-${i}`);
                    this.edges.push({
                        id: `outer-${i}-middle-${i}`,
                        nodes: [outerNode.id, middleNode.id],
                        weight: 5,
                        controlledBy: null
                    });

                    const innerNode = this.nodes.find(n => n.id === `inner-${i}`);
                    this.edges.push({
                        id: `middle-${i}-inner-${i}`,
                        nodes: [middleNode.id, innerNode.id],
                        weight: 15,
                        controlledBy: null
                    });
                }
            }

            startTimers() {
                this.intervalId = setInterval(() => this.updateTimers(), 1000);
            }

            updateTimers() {
                if (this.isPaused) return;

                if (this.overallTimer <= 0 || this.turnTimer <= 0) {
                    this.endGame();
                    return;
                }

                this.overallTimer--;
                this.turnTimer--;

                this.renderTimers();
            }

            renderTimers() {
                document.getElementById('overall-timer').textContent = 
                    `${Math.floor(this.overallTimer / 60)}:${(this.overallTimer % 60).toString().padStart(2, '0')}`;
                document.getElementById('turn-timer').textContent = this.turnTimer;
            }

            placeTitan(nodeId) {
                const node = this.nodes.find(n => n.id === nodeId);
                if (!node || node.occupant || !this.unlockedCircuits.includes(node.circuit)) return false;
                if (this.players[this.currentPlayer].titansPlaced >= 4) return false;

                node.occupant = this.currentPlayer;
                this.players[this.currentPlayer].titansPlaced++;
                this.checkCircuitFilled(node.circuit);
                this.updateEdgeControls(node.id);
                this.checkPhaseTransition();
                this.switchPlayer();
                return true;
            }

            moveTitan(fromNodeId, toNodeId) {
                const fromNode = this.nodes.find(n => n.id === fromNodeId);
                const toNode = this.nodes.find(n => n.id === toNodeId);
                if (!fromNode || !toNode || fromNode.occupant !== this.currentPlayer || toNode.occupant) return false;

                const isAdjacent = this.edges.some(edge => 
                    edge.nodes.includes(fromNodeId) && edge.nodes.includes(toNodeId));
                if (!isAdjacent) return false;

                fromNode.occupant = null;
                toNode.occupant = this.currentPlayer;

                this.updateEdgeControls(fromNodeId);
                this.updateEdgeControls(toNodeId);
                this.checkForEliminations(toNodeId);
                this.switchPlayer();
                return true;
            }

            checkCircuitFilled(circuit) {
                const circuitNodes = this.nodes.filter(n => n.circuit === circuit);
                const isFilled = circuitNodes.every(n => n.occupant !== null);
                if (isFilled && circuit === 'outer') this.unlockedCircuits.push('middle');
                else if (isFilled && circuit === 'middle') this.unlockedCircuits.push('inner');
            }

            checkPhaseTransition() {
                if (this.players.red.titansPlaced === 4 && this.players.blue.titansPlaced === 4) {
                    this.phase = 'movement';
                }
            }

            updateEdgeControls(nodeId) {
                const affectedEdges = this.edges.filter(edge => edge.nodes.includes(nodeId));
                affectedEdges.forEach(edge => {
                    const nodes = edge.nodes.map(id => this.nodes.find(n => n.id === id));
                    const occupants = nodes.map(n => n.occupant);
                    if (occupants[0] && occupants[0] === occupants[1]) {
                        if (edge.controlledBy !== occupants[0]) {
                            if (edge.controlledBy) this.players[edge.controlledBy].score -= edge.weight;
                            edge.controlledBy = occupants[0];
                            this.players[edge.controlledBy].score += edge.weight;
                        }
                    } else {
                        if (edge.controlledBy) {
                            this.players[edge.controlledBy].score -= edge.weight;
                            edge.controlledBy = null;
                        }
                    }
                });
            }

            checkForEliminations(nodeId) {
                const node = this.nodes.find(n => n.id === nodeId);
                if (!node.occupant) return;

                this.checkSurrounded(node);
                const adjacentEdges = this.edges.filter(edge => edge.nodes.includes(nodeId));
                adjacentEdges.forEach(edge => {
                    const adjNodeId = edge.nodes.find(id => id !== nodeId);
                    const adjNode = this.nodes.find(n => n.id === adjNodeId);
                    if (adjNode.occupant) this.checkSurrounded(adjNode);
                });
            }

            checkSurrounded(node) {
                const adjacentEdges = this.edges.filter(edge => edge.nodes.includes(node.id));
                const adjacentNodes = adjacentEdges.map(edge => {
                    const otherId = edge.nodes.find(id => id !== node.id);
                    return this.nodes.find(n => n.id === otherId);
                });

                const allOpponent = adjacentNodes.every(adjNode => 
                    adjNode.occupant && adjNode.occupant !== node.occupant);

                if (allOpponent) {
                    this.players[node.occupant].score -= this.calculateScoreLoss(node);
                    node.occupant = null;
                    this.updateEdgeControls(node.id);
                }
            }

            calculateScoreLoss(node) {
                let loss = 0;
                this.edges.filter(edge => edge.nodes.includes(node.id)).forEach(edge => {
                    if (edge.controlledBy === node.occupant) loss += edge.weight;
                });
                return loss;
            }

            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'red' ? 'blue' : 'red';
                this.turnTimer = 30;
                this.render();
            }

            render() {
                const svg = document.getElementById('game-board');
                svg.innerHTML = '';

                this.edges.forEach(edge => {
                    const node1 = this.nodes.find(n => n.id === edge.nodes[0]);
                    const node2 = this.nodes.find(n => n.id === edge.nodes[1]);
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', `M ${node1.x} ${node1.y} L ${node2.x} ${node2.y}`);
                    path.setAttribute('stroke', '#000');
                    path.setAttribute('stroke-width', '2');
                    svg.appendChild(path);

                    const midX = (node1.x + node2.x) / 2;
                    const midY = (node1.y + node2.y) / 2;
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', midX);
                    text.setAttribute('y', midY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', 'black');
                    text.textContent = edge.weight;
                    svg.appendChild(text);
                });

                this.nodes.forEach(node => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', node.x);
                    circle.setAttribute('cy', node.y);
                    circle.setAttribute('r', '15');
                    circle.setAttribute('fill', node.occupant || 'grey');
                    circle.setAttribute('stroke', this.selectedTitan === node.id ? 'yellow' : '#000');
                    circle.setAttribute('stroke-width', this.selectedTitan === node.id ? '4' : '2');
                    circle.addEventListener('click', () => this.handleNodeClick(node.id));
                    svg.appendChild(circle);
                });

                document.querySelector('.red').textContent = `Red: ${this.players.red.score}`;
                document.querySelector('.blue').textContent = `Blue: ${this.players.blue.score}`;
                document.getElementById('current-player').textContent = this.currentPlayer;
            }

            handleNodeClick(nodeId) {
                if (this.phase === 'placement') {
                    if (this.players[this.currentPlayer].titansPlaced < 4) {
                        this.placeTitan(nodeId);
                    } else {
                        const node = this.nodes.find(n => n.id === nodeId);
                        if (node.occupant === this.currentPlayer) {
                            this.selectedTitan = this.selectedTitan === nodeId ? null : nodeId;
                        } else if (this.selectedTitan) {
                            this.moveTitan(this.selectedTitan, nodeId);
                            this.selectedTitan = null;
                        }
                    }
                } else if (this.phase === 'movement') {
                    if (this.selectedTitan) {
                        this.moveTitan(this.selectedTitan, nodeId);
                        this.selectedTitan = null;
                    } else {
                        const node = this.nodes.find(n => n.id === nodeId);
                        if (node.occupant === this.currentPlayer) {
                            this.selectedTitan = nodeId;
                        }
                    }
                }
                this.render();
            }

            endGame() {
                clearInterval(this.intervalId);
                const winner = this.players.red.score > this.players.blue.score ? 'Red' : 'Blue';
                alert(`Game Over! Winner: ${winner}`);
            }
        }

        const game = new Game();

        document.getElementById('pause-btn').addEventListener('click', () => {
            game.isPaused = !game.isPaused;
            document.getElementById('pause-btn').textContent = game.isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            location.reload();
        });
    </script>
</body>
</html>